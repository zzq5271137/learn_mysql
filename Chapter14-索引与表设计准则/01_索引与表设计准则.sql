/*
 * 重点学习:
 * 1. 如果写出高质量的sql
 * 2. 如果保证索引不失效
 */

/*
 * -------------------索引-------------------
 * 详见xmind文档
 */

/*
 * -------------------数据库表的设计准则-------------------
 * 若完全不考虑三范式（比如员工和部门等信息全部存储进一张表），那么可能会有很多问题，比如：
 * a). 数据冗余，比如每行记录都有部门信息
 * b). 插入异常，比如想要为一个新部门插入部门信息，但是没有员工信息
 * c). 更新异常，比如想要更新某一个部门的信息（例如修改部门地址），就需要更新多条记录，因为部门信息是冗余的
 * d). 删除异常，比如有一个部门有3条记录（有3个员工），假如这三个员工都离职了，需要删除掉这三条记录，那么部门记录也就随之完全消失了
 *
 * 规范化：
 * 规范化（Normalization）是用于数据库设计的一系列原理和技术，它可以减少表中数据的冗余，增加数据完整性和一致性。
 * 数据库三范式如下：
 * 1. 1NF
 *    第一范式是指，表中的字段都是不可再分割的原子属性，同时表需要有一个主键
 * 2. 2NF
 *    第二范式首先需要满足第一范式。非主键字段必须完全依赖主键字段，不能只依赖于主键的一部分。
 *    比如一张表包含了员工和部门信息，主键为员工id，其中部门信息其实并不依赖员工id。所以为了满足第二范式，可以把表拆成员工表和部门表，然后在员工表中使用外健关联部门表。
 * 3. 3NF
 *    第三范式首先需要满足第二范式。非主键字段不能依赖于其他非主键字段（也就是所谓的传递依赖）。
 *    比如一张表包含了员工信息，里面有职位和薪资范围的字段，但其实薪资范围依赖于职位，也就是说对某一记录的职位进行修改的时候，也会修改他的薪资范围。
 *    所以为了满足第三范式，需要把职位和薪资范围拆成单独的表，然后在员工表中使用外健关联。
 * 数据库三范式简单来说就是大表拆小表，每一个表都是单纯描述一个对象。
 *
 * 反规范化：
 * 为了提高查询性能可以降低规范化的级别，也就是反规范化（Denormalization）。
 * 目的是为了减少联表查询，提高查询效率。比如可以增加冗余字段、增加计算列、讲小表合成大表等。
 *
 * 关于是否使用外健：
 * 外健是数据库用于实现参照完整性的约束，可以保证数据的完整性和一致性。
 * 但是在有一些场景，例如互联网下的追求高效率的场景和分库分表的场景，可以不做数据库的外健约束，而是在业务代码中进行数据的完整性和一致性校验。
 *
 * ref：https://www.bilibili.com/video/BV1ZS4y1a7jG/?spm_id_from=333.788
 *
 * 2. 大表拆小表, 有大数据的列单独拆成小表
 *    在一个数据库中, 一般不会设计属性过多的表;
 *    在一个数据库中, 一般不会有超过500/1000万数据的表, 拆表;
 *    有大数据的列单独拆成小表(富文本编辑器, CKeditor);
 *
 * 详见xmind文档
 */

/*
 * -------------------DQL的执行过程-------------------
 * 这里DQL的执行过程, 不是指DQL语句的解析过程, 而是客户端向数据库发送一条DQL语句, 它整个经历的过程;
 *
 * 详见xmind文档
 */
