/*
 * --------------------MySQL中的锁机制--------------------
 * 锁的分类:
 * 1. 按操作分:
 *    a). 读锁(共享锁):
 *        针对同一份数据, 多个读取操作可以同时进行而不互相影响;
 *        对于表锁:
 *        当MySQL的一个进程为某一表开启读锁之后, 其他的进程包含自身都没有权利去修改这表的内容(因为写锁是排他的);
 *        这里说的其他进程不能更新这张表, 严格来说是更新操作被阻塞了(处于等待状态), 等待别人解锁后, 才能进行更新;
 *        但加锁的那个进程, 是不能更新这张表的(直接会更新失败);
 *        但是所有的进程还是可以读出表里面的内容的;
 *        对这张表加读锁的这个进程, 也不能去读别的表, 它只能读取它锁住的这张表;
 *        对于行锁:
 *        当MySQL的一个进程对一条记录加上读锁后, 这个进程能够读取其他数据, 也能够更新这条数据(改进程能够更新数据的前提是，没有其他进程拿到了该行数据的共享锁，否则该线程更新数据会报错);
 *        其他进程也能够读取这条数据, 但是对这条数据的更新会进入阻塞状态;
 *    b). 写锁(排它锁):
 *        当前写操作没有完成前, 会阻断其他写锁和读锁;
 *        写锁是排他的, 也就是说一个写锁会阻塞其他的读锁和写锁, 也会阻塞其他进程的读写操作;
 *        对于表锁:
 *        当MySQL的一个进程给某一张表开启写锁后, 这个线程可以读这个表, 也可以更新这张表, 但不能读取别的表;
 *        其他进程不能读这张表, 也不能写这张表(读写都是被阻塞的, 也就是处于等待状态);
 *        对于行锁:
 *        当MySQL的一个进程对一条记录加上写锁后, 其他进程可以读这条记录, 但是只能读到旧的数据,
 *        读不到为这条记录加上写锁的进程还没有commit的数据;
 *        但是其他进程对这条记录的更新会进入阻塞状态;
 * 2. 按粒度分:
 *    a). 表锁:
 *        整张表就只能一个人使用;
 *        偏向MYISAM存储引擎, 开销小, 加锁快, 无死锁, 锁定粒度大, 发生锁冲突的概率最高, 并发度最低;
 *        表锁一般用在读取比较多更新比较少的表;
 *        对表加锁:
 *        加读锁为lock table locktest read;
 *        加写锁为lock table locktest write;
 *        对表进行解锁: unlock tables;
 *    b). 行锁
 *        偏向InnoDB存储引擎, 开销大, 加锁慢, 会出现死锁, 锁定粒度最小, 发生锁冲突的概率最底, 并发度也最高;
 *        InnoDB与MyISAM的最大不同点: 一是支持事务, 二是采用了行级锁;
 *        对行加写锁:
 *        行锁与MySQL中事务的隔离级别密切相关;
 *        如果事务的隔离级别为Repeatable Read(这也是MySQL默认的), 当一个进程在修改(update)一条数据时,
 *        默认会给这条数据加上行锁(写锁),
 *        此时, 其他进程对这条数据的修改会进入阻塞状态, 等其commit之后, 才可以执行更新;
 *        或者，在一个事务中，可以手动给某行数据加上写锁(排他锁)：select * from employee where id = 1 for update;
 *        行锁有可能会变成表锁:
 *        索引失效导致行锁变表锁, 也就是说, 不能准确定位到想要更新的记录, 就需要全表扫描, 即行锁变成表锁;
 *        对行加读锁:
 *        想要在查询时为一条记录加上读锁(共享锁), select * from employee where id = 1 lock in share mode;
 *        还存在间隙锁, 即当我们使用范围条件, 而不是相等条件检索数据, 并请求共享或排它锁时;
 *    c). 页锁
 * 3. 悲观锁与乐观锁
 *    a). 悲观锁
 *        就是很悲观, 它对于数据被外界修改持保守态度，认为数据随时会修改, 所以整个数据处理中需要将数据加锁;
 *        悲观锁一般都是依靠关系数据库提供的锁机制, 事实上关系数据库中的行锁, 表锁不论是读写锁都是悲观锁;
 *    b). 乐观锁
 *        顾名思义, 就是很乐观, 每次自己操作数据的时候认为没有人回来修改它, 所以不去加锁;
 *        但是在更新的时候会去判断在此期间数据有没有被修改, 需要用户自己去实现;
 *        不会发生并发抢占资源, 只有在提交操作的时候检查是否违反数据完整性;
 *        为什么要使用乐观锁呢:
 *        对于读操作远多于写操作的时候, 大多数都是读取, 这时候一个更新操作加锁会阻塞所有读取, 降低了吞吐量;
 *        最后还要释放锁, 锁是需要一些开销的, 我们只要想办法解决极少量的更新操作的同步问题;
 *        换句话说, 如果是读写比例差距不是非常大或者你的系统没有响应不及时, 吞吐量瓶颈问题,
 *        那就不要去使用乐观锁, 它增加了复杂度, 也带来了额外的风险;
 *        乐观锁的实现方式: (1). 版本号 (2). 时间戳
 *
 * 详见xmind文档;
 *
 * 资料：
 * 1. https://www.zhoulujun.net/html/DB/mysql/2019_1014_8173.html
 * 2. https://zhuanlan.zhihu.com/p/48127815
 * 3. https://zhuanlan.zhihu.com/p/48269420
 * 4. https://zhuanlan.zhihu.com/p/29150809
 */